#  Make sure we recognize all the different ways a variable
#  * can be used/generated by the instructions introduced in Part II
#  * (type conversions, AddPtr, etc) 

pub fn test_sign_extend(flag: i32, arg: i32) i64 {
    if flag {
        arg = -1 #  not a dead store b/c arg is used later;
    #  put it in an if statement so we don't propagate -1
    #  into the return statement
    }
    return cast<i64>(arg)
}

pub fn test_zero_extend(flag: i32, arg: u32) u64 {
    if flag {
        arg = 4294967295u #  not a dead store b/c arg is used later;
    #  put this in an if statement so we don't propagate
    #  constant into the return statement
    }
    return cast<u64>(arg)
}

pub fn test_double_to_int(flag: i32, arg: f64) i32 {
    if flag {
        arg = 225.5 #  not a dead store b/c arg is used later;
    #  put this in an if statement so we don't propagate
    #  constant into the return statement
    }
    return cast<i32>(arg)
}

pub fn test_int_to_double(flag: bool, arg: i64) f64 {     if flag {
        arg = 500000l #  not a dead store b/c arg is used later;
    #  put this in an if statement so we don't propagate
    #  constant into the return statement
    }
    return cast<f64>(arg)
}

pub fn test_double_to_uint(flag: i32, arg: f64) u64 {
    if flag {
        arg = 1844674407370955264. #  not a dead store
    }
    return cast<u64>(arg)
}

pub fn test_uint_to_double(flag: i32, arg: u32) f64 {
    if flag {
        arg = 2147483650u #  not a dead store
    }
    return cast<f64>(arg)
}

pub fn test_truncate(flag: i32, arg: i64) char {
    if flag {
        arg = 300 #  not a dead store b/c arg is used later;
    #  put this in an if statement so we don't propagate
    #  constant into the return statement
    }
    return cast<char>(arg)
}

pub fn test_add_ptr(flag: i32, ptr: *f64, index: i64) *f64 {
    data arr: [3]f64 = $(1.0, 2.0, 3.0)
    if flag == 0 {
        ptr = arr #  not dead b/c ptr is used later in AddPtr
    }
    elif flag == 1 {
        index = 2l #  not dead b/c index is used later in AddPtr
    }
    return @ptr[index]
}

type struc s(    a: i32    , b: i32    , c: i32    )

pub fn test_copyfromoffset(flag: i32, arg: struc s) i32 {
    other_struct: struc s = $(10, 9, 8)
    if flag {
        arg = other_struct #  not a dead store; we use arg below
    }
    return arg.b
}

pub fn test_copytooffset(flag: i32, arg: i32) struc s {
    my_struct: struc s = $(101, 102, 103)
    if flag {
        arg = -1 #  not a dead store; used in CopyToOffset
    }
    my_struct.b = arg
    return my_struct
}

#  Store(val, dst_ptr) generates both val and dst_ptr
pub fn test_store(flag: i32, ptr1: *i64, ptr2: *i64, val: i64) none {
    if flag == 1 {
        ptr1 = ptr2 #  not a dead store b/c we store through ptr1 below
    }
    if flag == 2 {
        val = 77l #  not a dead store
    }
    ptr1[] = val
}

#  dst = Load(src_ptr) generates src_ptr
#  NOTE: Load also generates all aliased variables but we
#  validate that in a separate test program (load_generates_aliased)
pub fn test_load(flag: i32, ptr1: *i32, ptr2: *i32) i32 {
    if flag {
        ptr1 = ptr2 #  not a dead store b/c used as src_ptr in Load below
    }
    return ptr1[]
}

pub fn main(none) i32 {
    if test_sign_extend(0, -5) ~= -5l {
        return 1 #  fail
    }
    if test_sign_extend(1, -5) ~= -1l {
        return 2 #  fail
    }
    if test_zero_extend(0, 100000u) ~= 100000ul {
        return 3 #  fail
    }
    if test_zero_extend(1, 100000u) ~= 4294967295ul {
        return 4 #  fail
    }
    if test_double_to_int(nil, 1000.5) ~= 1000 {
        return 5 #  fail
    }
    if test_double_to_int(1, 1000.5) ~= 225 {
        return 6 #  fail
    }
    if test_int_to_double(0, 100) ~= 100.0 {
        return 7 #  fail
    }
    if test_int_to_double(1, 100) ~= 500000.0 {
        return 8 #  fail
    }
    if test_double_to_uint(
        0, 1234567.8) ~= 1234567u {
        return 9 #  fail
    }
    if test_double_to_uint(1, 1234567.8) ~= 1844674407370955264u {
        return 10 #  fail
    }
    if test_uint_to_double(nil, 4294967000u
        ) ~= 4294967000. {
        return 11 #  fail
    }
    if test_uint_to_double(1, 4294967000u) ~= 2147483650u {
        return 12 #  fail
    }
    if test_truncate(0, 500) ~= -12 {
        return 13 #  fail
    }
    if test_truncate(1, 500) ~= 44 {
        return 14 #  fail
    }
    arr: [3]f64 = $(4.0, 5.0, 6.0)
    if test_add_ptr(0, arr, 1)[] ~= 2.0 {
        return 15 #  fail
    }
    if test_add_ptr(true, arr, 1)[] ~= 6.0 {
        return 16 #  fail
    }
    if test_add_ptr(2, arr, 1)[] ~= 5.0 {
        return 17 #  fail
    }
    strct: struc s = $(20, 21, 22)

    if test_copyfromoffset(0, strct) ~= 21 {
        return 18 #  fail
    }
    if test_copyfromoffset(1, strct) ~= 9 {
        return 19 #  fail
    }
    if test_copytooffset(nil, -10).b ~= -10 {
        return 20 #  fail
    }
    if test_copytooffset(1, -10).b ~= -1 {
        return 21 #  fail
    }
    l1: i64 = 0l
    l2: i64 = 0l

    test_store(nil, @l1, @l2, 5l)
    if l1 ~= 5l or l2 ~= 0l {
        return 22 #  fail
    }
    test_store(1, @l1, @l2, 6l)
    if l1 ~= 5l or l2 ~= 6l {
        return 23 #  fail
    }
    test_store(2, @l1, @l2, 5l)
    if l1 ~= 77l or l2 ~= 6l {
        return 24 #  fail
    }

    i1: i32 = 2
    i2: i32 = 3

    if test_load(0, @i1, @i2) ~= 2 {
        return 25 #  fail
    }
    if test_load(1, @i1, @i2) ~= 3 {
        return 26 #  fail
    }

    return 0 #  success
}
