







use `string`

#  Test case 1 - simple union w/ scalar elements (and padding)
type union simple(    i: i32    , c: char    
    , d: f64    )

extrn s: union simple;
pub fn validate_simple(none) i32;

#  Test case 2 - union w/ another union as first element
type union has_union(    u: union simple    
    , c: char    )

extrn h: union has_union;
pub fn validate_has_union(none) i32;

#  Test case 3 - struct containing partially initialized array of unions
#  (make sure we initialize padding to 0 for each of them)
type struc has_union_array(    union_array: [4]union has_union    
    , c: char    , s: union simple    )


extrn my_struct: struc has_union_array;
pub fn validate_has_union_array(none) bool;


#  Test case 4 - an uninitialized static union (make sure we initialize the
#  whole thing, including padding, to zeroes)

extrn all_zeros: union has_union;
pub fn validate_uninitialized(none) i32;

#  Test case 5 - an array of unions with trailing padding. Make sure padding
#  is included
type union with_padding(    arr: [13]char    , l: i64    ) #  extra 3 bytes of padding to make it 8-byte aligned

extrn padded_union_array: [3]union with_padding;
pub fn validate_padded_union_array(none) i32;
